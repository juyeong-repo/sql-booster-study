## INNER JOIN

### INNER JOIN 조건의 특징

만족하는 데이터만 결합되어 결과에 나올 수 있다.

(같다(=)뿐만 아니라, 다른 조건식도 사용될 수 있다.)

1건과 多건이 조인되면 多건이 나온다.

<img width="1211" height="364" alt="image" src="https://github.com/user-attachments/assets/7ba9110b-4152-4b6f-bb60-9cceef7fcb9e" />

```sql
SELECT T1.CUS_ID, T1.CUS_GD, T2.ORD_SEQ, T2.CUS_ID, T2.ORD_DT

FORM M_CUS T1, T_ORD T2

WHERE T1.CUS_ID = T2.CUS_ID

AND T1.CUS_GD = ‘A’

AND T2.ORD_DT ≥ TO_DATE(’20170101’, ‘YYYYMMDD’)

AND T2.ORD_DT < TO_DATE(’20170201’, ‘YYYYMMDD’)
```

1. M_CUS에서 CUS_GD가 A인 데이터만 찾아낸다.(필터 조건 처리)
2. M_CUS의 첫 번째 로우인 CUS_1과 같은 CUS_ID가 T_ORD에 있는지 검색한다.
    
    :T_ORD에 CUS_1이 존재하지만 ORD_DT가 2017년2월 이므로 조인 실패
    
    (T_ORD의 필터 조건이 2017년 1월의 주문만 처리했기 때문)
    
3. M_CUS의 세번째 로우인 CUS_3과 같은 CUS_ID가 T_ORD에 있는지 검색한다.
    
    :T_ORD에는 CUS_3이 두 건 존재한다. ORD_DT도 2017년 1월이므로 조인에 성공
    
    (M_CUS의 CUS_3 한 건은 T_ORD의 두 건과 조인이 이루어진다)
    
4. M_CUS의 네 번째 로우인 CUS_4와 같은 CUS_ID가 T_ORD에 있는지 검색한다.
    
    :T_ORD에 CUS_4는 한 건 존재한다. ORD_DT도 2017년 1월이므로 조인에 성공한다.

→ T_ORD에서 M_CUS로 조인을 걸어도 결과는 같다. 다만 성능에서 차이가 생길 수 있다.

→ 조인 조건을 사용할 때, T1.COL = T2.COL로 쓰게 되면 같은 값끼리만 조인한다고 착각할 수 있는데 ≠으로도 조인 할 수 있다.

→ 조건을 충족하는 데이터들끼리의 결합이라고 생각해야 한다.


### 조인을 잘하기 위해서는

테이블 자체를 데이터 집합으로 볼 수 있다.

WHERE절의 필터 조건을 거친 결과를 데이터 집합이라 할 수 있다.

두 개의 데이터 집합이 조인된 결과는 새로운 하나의 데이터 집합이다.


### 여러 테이블을 조인할 때 주의사항

한순간에는 두 개의 데이터 집합에 대해서만 조인이 발생.

조인이 이루어진 두 개의 데이터 집합은 새로운 하나의 데이터 집합이다.

테이블 간의 관계를 이해하고 조인을 작성.(=업무적인 관계를 이해하자)


### DISTINCT를 만났을 때

간혹 조인이 잘못되어 중복데이터가 나오니 DISTINCT를 걸어놓는 경우가 있을 수 있으므로 SQL 조인 관계를 잘 살펴보자

### 그 외 주의사항

多:多 조인은 OLTP환경에선 발생할 일이 거의 없다. (多:多관계가 있어선 안된다는 게 더 정확한 표현)

그럼에도 多:多 조인이 있다면 테이블 설계에 문제가 있거나 조인을 잘못 걸고 있는 것.

**OLTP(Online Transaction Processing)** 환경이란 실시간으로 다수의 사용자가 데이터베이스에서 빠르게 트랜잭션을 처리할 수 있도록 설계된 시스템을 뜻한다

(EX. 은행 시스템, 전자상거래 시스템, 공장 관리 시스템)

### M:1:M을 조인해야 하는 상황에 놓인다면

조인이 아닌 UNION ALL을 사용해 해결을 하거나 M:1을 먼저 조인해서 하나의 데이터 집합으로 만들어 놓은 후 나머지 조인을 걸어야 한다. 또는 모두 1로 만들어 놓고 1:1:1로 조인해야함.

여기서 모두 1로 만든다는 것은 GROUP BY를 이용하는 것.


## RANGE-JOIN(범위 조인)

가격유형별로 주문 건수를 카운트해야하는 상황에서 사용된다.

말 그대로 범위내 조인인 셈

GROUP BY ~CASE를 테이블과 조인해서 사용하는 것이 에시.

## OUTER JOIN

INNER JOIN에 더해 만족하지 않은 데이터도 나오는 조인

이를 이해하기 위해선 기준 데이터집합과 참조 데이터집합이 필요하다.

여기서 기준 데이터집합은 조인 조건을 만족하지 않아도 모두 결과에 포함됨

(단, 필터 조건은 만족해야 한다.)

### OUTER JOIN 조건의 특징

기준 데이터 집합은 조인 조건에(+)가 없는 쪽

참조 데이터 집합은 조인 조건에 (+)가 표시된 쪽

기준 데이터 집합은 조인 성공 여부와 상관없이 모두 나옴(필터 조건은 만족해야함)

만족되지 못한 집합 결과는 NULL로 채워져 나온다.

+가 붙은 데이터 집합이 기준 데이터에 붙는 것이라고 생각하기

참조 데이터 집합 필터 조건에 (+)를 표시하면?

: 아우터 조인 전에 필터가 됨

참조 데이터 집합 필터 조건에 (+)를 표시하지 않으면?

: 아우터 조인 후 필터가 됨

참조 데이터 집합이 다른 집합과 조인될 때는 기준 집합으로서 아우터 조인해야함

아우터 조인에서 (+)표시가 된 참조 데이터 집합은 두 개 이상의 기준 데이터 집합을 동시에 가질 수 없다.(SQL버전에 따라 상이할 수 있음)

## CARTESIAN-JOIN(묻지마 조인) = CROSS JOIN

크로스 조인이 좀 더 공식적인 용어임. 조인 조건이 없는 조인을 뜻함.

<img width="932" height="645" alt="image" src="https://github.com/user-attachments/assets/208157c0-9dd4-4606-a62f-053bc27307c4" />

### CROSS JOIN 조건의 특징

CUS_GD의 종류를 가져온 데이터 집합

ITM_TP의 종류를 가져온 데이터 집합

모든 데이터가 서로 합쳐짐

사용이 매우 드문 조인이며 BI환경에서 분석 차원 집합을 만들거나 시스템 오픈 전에 대량 테스트 데이터 만드는 것에 일회성으로 사용되곤 한다.

시스템 성능을 저하시키거나 장애를 일으킬 수 있으므로 조심해야함.

다만 분석마스터를 만들기엔 용이하고 (예시 : 특정 고객 두 명의 2월, 3월, 4월 월별 주문 건수 - 주문이 없는 월은 0으로 나오도록 처리할 때) 성능 테스트나 부하 테스트 등을 위한 다량의 더미 테스트 데이터를 만들 때 용이하게 쓸 수 있음

---

### INNER JOIN 실행 계획

| Type | nodeName | Cost | Rows |
| --- | --- | --- | --- |
| select | -------------- | 36,012.89 | 891 |
| ordering_operation | -------------- | 6,669 | 891 |
| nested_loop#1 | -------------- | 2 | 31 |
| table | TA(ALL) | 2.89 | 31 |
| query_block | -------------- | 5.99 | 31 |
| grouping_operation | -------------- | 2 | 31 |
| table | TA(ALL) | 2.89 | 31 |
| query_block | -------------- | 4,648.87 | 6,313 |
| nested_loop#1 | -------------- | 666 | 6,254 |
| table | **TB(ALL)** | 666.61 | 6,254 |
| nested_loop#2 | -------------- | 236 | 58 |
| table | TA(ref) | 236.76 | 58 |
| table | tbl_spc_goods_inspect(eq_ref) | 0.25 | 1 |
| nested_loop#2 | -------------- | 6,667 | 860 |
| table | TB(ref) | 860 | 6,667.94 |
| query_block | -------------- | 9,530.05 | 86,038 |
| grouping_operation | -------------- | 926 | 86,038 |
| table | TA(index) | 926.25 | 86,038 |
| attached_subqueries#1 | -------------- | 3,413 | 1 |
| table | <materialized_subquery>(eq_ref) | 3,413 | 1 |
| query_block | -------------- | 3,413.81 | 4,723 |

실행 속도 : 26초

- TB 테이블이 “ALL” 접근 방식으로 전체 스캔되고 있으며, 중첩 루프(nested_loop)가 TB에 대해 반복적으로 전체 행을 읽는 방식으로 진행되어 비용이 높게 산출되었음. 이로 인해 불필요한 행 스캔과 비용이 누적되어 실제 실행 시간이 오래 걸린 것으로 추정

- 

---

### STRAIGHT_JOIN 실행 계획

| Type | nodeName | Cost | Rows |
| --- | --- | --- | --- |
| select | -------------- | 117,121.64 | 8,613 |
| ordering_operation | -------------- | 21,619 | 8,613 |
| nested_loop#1 | -------------- | 110 | 8,603 |
| table | TA(ALL) | 110.04 | 8,603 |
| query_block | -------------- | 970.34 | 8,603 |
| grouping_operation | -------------- | 110 | 8,603 |
| table | TA(ALL) | 110.04 | 8,603 |
| query_block | -------------- | 39,643.35 | 86,040 |
| nested_loop#1 | -------------- | 926 | 86,038 |
| table | TA(ALL) | 926.25 | 86,038 |
| nested_loop#2 | -------------- | 21,509 | 1 |
| table | **TB(eq_ref)** | 21,509.5 | 1 |
| table | tbl_spc_goods_inspect(eq_ref) | 0.25 | 1 |
| nested_loop#2 | -------------- | 21,509 | 10 |
| table | TB(ref) | 21,509.5 | 10 |
| query_block | -------------- | 9,530.05 | 86,038 |
| grouping_operation | -------------- | 926 | 86,038 |
| table | TA(index) | 926.25 | 86,038 |
| attached_subqueries#1 | -------------- | 3,413 | 1 |
| table | <materialized_subquery>(eq_ref) | 3,413 | 1 |
| query_block | -------------- | 3,413.81 | 4,723 |

실행 속도 : 1.881초

- STRAIGHT_JOIN은 FROM 절에 나열된 순서를 강제하여, TB 테이블에 대해 “eq_ref” 또는 “ref” 접근 방식을 사용하게 함. 그 결과, TB에 대해 효율적인 인덱스 사용이 가능해지고, 불필요한 전체 스캔(ALL)이 발생하지 않으면서 비용과 반복 횟수도 줄어듬

TA(ALL) 보다 TB(ALL)의 개선이 시급했던 이유

→ 

- **반복적인 전체 스캔으로 인한 비용 누적**: TB 테이블이 ALL 방식으로 스캔되면, 조인 과정에서 반복적으로 전체 데이터를 읽게 되어 비용이 기하급수적으로 증가. 특히 Nested Loop 조인에서는 한 테이블의 스캔이 다른 테이블과 반복적으로 결합되므로 전체 비용에 큰 영향을 미치게 됨.
- **조인 순서와 역할의 차이**: TA 테이블의 경우, 일부 실행 계획에서 전체 스캔(ALL)이 발생하더라도 해당 테이블의 크기나 해당 조인 블록에서의 역할이 상대적으로 적은 경우 전체 쿼리 비용에 미치는 영향이 낮을 수 있음. 반면 TB 테이블은 조인에서 주도적인 역할을 하거나, 반복적으로 접근되어 비용 부담이 더 크기 때문에 시급하게 개선되어야 했음.

→ 따라서, TA(ALL)의 행 수가 8,603건이라고 하더라도, TB(ALL) 방식이 Nested Loop 등에서 반복되어 발생하는 비용이 전체 성능에 더 큰 영향을 주기 때문에 TB의 접근 방식을 개선하는 것이 우선 과제가 되는 것.

여기서 TA테이블과 TB테이블의 성격을 보면 엔티티 성격(1)을 가진 테이블이 TB고 TA가 多

- **system**: 테이블에 단 한 행만 존재할 때 사용됩니다.
- **const**: 테이블이 상수로 처리되어 한 번만 읽히는 경우입니다.
- **eq_ref**: 이전 테이블의 각 행에 대해 조인 대상에서 최대 한 행만 일치할 때 사용되며, 가장 효율적인 조인 유형입니다.
- **ref**: 이전 테이블의 각 행에 대해 하나 이상의 행을 찾을 수 있는 경우에 사용됩니다.
- **range**: 인덱스를 활용해 특정 범위의 값을 검색할 때 사용됩니다.
- **index**: 인덱스 풀 스캔을 사용하여 데이터를 검색하는 방식으로, FULL TABLE SCAN보다 약간 효율적입니다.
- **ALL**: 전체 테이블 스캔을 의미하며, 가장 비효율적인 방식입니다.

   
