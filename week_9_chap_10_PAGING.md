

# **9.3 분석함수를 대신하기**

### **9.3.1 분석함수를 대신하는 방법**

- **서브쿼리, 인라인-뷰, SELF JOIN**을 활용해 `OVER`, `PARTITION BY` 등을 대체할 수 있다.
- 분석함수를 직접 지원하지 않는 환경에서 유용한 기법들이다.

### **SELF JOIN이란?**

- 자기 자신과의 조인으로, 집계 데이터와 상세 데이터를 한 쿼리로 처리한다.
- 예시론 순위매기기, 누적합 구하기, 전월/전일비교
- 분석함수를 사용하면 되는 내용들이지만 db버전이 너무 낮아 분석함수를 쓸 수 없을 때, 분석함수 사용 시 성능적 문제가 있을 때, 복잡한 계산 과정에서 대체안으로 고려할 수 있음

---

### **9.3.2 PARTITION BY를 대신하기**

- `PARTITION BY` 없이 **서브쿼리** 또는 **인라인-뷰**로 그룹별 집계 데이터를 얻는다.
- 그룹별 집계함수를 ‘별도로’사용해야 할때가 포인트
- 누적합, 순위, 비율, 증감 등의 계산에 많이 사용됨

---

### **9.3.3 ROW_NUMBER를 대신하기**

- `ROW_NUMBER`가 지원되지 않거나, 성능상 이슈가 있을 때 대체 기법.

### **ROWNUM으로 대체**

- `ROWNUM`을 사용해 순번을 매김.
- 정렬된 결과를 인라인-뷰로 먼저 처리 ➜ `ROWNUM` 조건을 적용.
- 두 번째 페이지 이상의 경우, 반드시 인라인-뷰로 처리해야 정확.
- 순위를 매기는 과정에서 사용이 되는데 현업에서 그룹별 가장 최근 날짜에 해당되는 데이터를 가져오기 위해 row_number로 줄을 세운 뒤 1에 해당하는 내용들만 가져오도록 활용한 적이 있음(성능개선건)

---

# **Chapter 10.1 페이징 처리 기술**

### **10.1.1 페이징의 종류**

- **WAS 페이징**: WAS에서 30건만 꺼내 보여줌.
- **DB 페이징**: SQL `ROWNUM`으로 DB가 직접 30건만 조회.
- **DB-INDEX 페이징**: 인덱스 기반으로 필요한 30건만 읽음 ➜ 최적의 성능.

---

### **DB 페이징 (ROWNUM 기반)**

- **ROWNUM**을 정렬과 함께 사용해야 원하는 순서대로 결과가 나온다.
- 1부터 차례대로 번호를 매기는 방식이기 때문에 1을 거치지 않고 2,3이 나올 수 없다는 부분 꼭 염두하고 쿼리를 짜야함

---

### **DB-INDEX 페이징**

- 인덱스 기반으로 원하는 30건만 읽음 ➜ `0.01초 이내` 처리 가능.
    - 인덱스는 `WHERE` 절에 조건으로 사용된 컬럼을 복합 인덱스의 선두 컬럼으로 사용
        - 조건이 여러개라면 같다(=) 조건의 컬럼을 앞쪽에 범위 조건을 뒤에 둔다.
    - `ORDER BY` 에 사용된 컬럼을 위에서 정의한 컬럼 뒤에 차례대로 위치시킨다.
- 아무리 인덱스를 구성해도 where절 조건과 order by에 따라 db-index는 작동하지 않을 수 있으므로 실행계획을 통해 확인해야함
- `INDEX RANGE SCAN DESCENDING`, `COUNT STOPKEY` 등이 사용됨.(적용이 잘 되었다면 실행계획에서 확인 가능하다)

---

### **실행계획 성능 비교**

- **DB-INDEX 페이징**이 가장 빠르고 효율적.
- 100번째 페이지도 3,000건만 읽음 (WAS 페이징은 30,000건 전부 읽음).
- **하지만 정렬 기준**이 바뀌면 새로운 인덱스 필요 ➜ 관리 비용 발생.

---

### **집계함수 포함된 경우**

- 집계함수를 포함한 정렬(`SUM`, `MAX` … `ORDER BY`)은 모든 데이터를 처리 후 정렬해야 하므로 DB-INDEX 페이징을 못 쓰는 경우도 있다.

---

- **DB-INDEX 페이징**: 성능이 가장 좋다 하지만 정렬 컬럼/인덱스 설계시 주의가 필요하며 인덱스가 꼭 잘 걸려야 한다.
- **정렬순서 바뀌면?**  새로운 인덱스가 필요하며 유지보수 비용이 발생할 수 있다.
- **집계함수+정렬** ➜ DB-INDEX 페이징 불가하다면 집계 후 정렬 필요
- 정답으로 정해진 것은 없고 모든 상황에 맞춰 **유연한 선택**과 **인덱스 설계**가 중요하다
