# SQL BOOSTER_CHAP.5 성능개선을 위한 기본지식 

## 1. 실행계획

### 1.1 유의사항

**성능개선에 절대적인 규칙은 없다. 개발상황과 업무로직, 데이터양 등의 조건에 따라 자신이 판단하여 개선해야한다.** 

- “좌변은 절대 가공하지말라”
    - WHERE절에서 칼럼을 가공하지 말라는 말.
    - 컬럼을 가공하면 인덱스를 사용못한다는 뜻인데 원리를 파악해야함
- NL조인에서 크기가 작은 집합이 선행집합이면 일반적으로 효율이 좋지만 페이징SQL에서는 꼭 그렇지 않다
- 페이징 기준이 크기가 큰 테이블쪽에있다면 선행집합으로 큰테이블을 선택하는것이 NL조인 성능에 좋다

🤔 NL조인? 

```sql
NL 조인(Nested Loop Join)은 관계형 데이터베이스에서 사용되는 가장 기본적인 조인 알고리즘입니다. 중첩 루프 조인이라고도 불립니다.
NL 조인의 작동 방식

첫 번째 테이블(외부 테이블 또는 드라이빙 테이블)에서 행을 하나씩 읽습니다.
읽은 각 행에 대해, 두 번째 테이블(내부 테이블)을 전체 스캔하거나 인덱스를 통해 탐색하여 조인 조건을 만족하는 행을 찾습니다.
조건을 만족하는 행들을 결합하여 결과 집합에 추가합니다.

-> 이중 for 문 하고 똑같이 동작하는구나. a 테이블에 사람이 3, b테이블에 과일 종류가 5개면, 3*5= 15 번 살펴보는 것. 
```

### 1.2 실행계획

🤔 SQL을 처리하기 위해 DBMS가 내부적으로 만드는 작업계획서. 

- SQL 구문분석 > 실행계획생성 > 실행계획 대로 SQL처리
    
    ```sql
    - 오라클: EXPLAIN PLAN FOR ~
    - MYSQL : EXPLAIN ~
    ```
<img width="874" height="103" alt="image" src="https://github.com/user-attachments/assets/012be2a2-4832-4224-afd0-504532ba68f2" />  

A 와 B 테이블을 조인하는 쿼리
<img width="2048" height="167" alt="image" src="https://github.com/user-attachments/assets/f5d148c8-7e3d-4ca7-85b1-ad357fb03b71" />
- SQL실행전 데이터를 어떤 방법과 순서를 처리할지 실행계획을 생성, 그러므로 실행계획에 따라 성능이 달라진다.
- SQL**성능을 개선하려면 실행계획에 대한 이해**가 필요하다.

### 1.3 실행계획 확인하기(예상 실행계획)

- 여러가지 방법이있다.
    - SQL DEVELOPER에서 F10
    - TOAD CTRL+E
    - EXPLAIN PLAN FOR쿼리
    - SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());

### 1.4 실행계획의 순서

- 오퍼레이션 실행순서는 SQL성능을 좌우하는 중요한 요소중 하나.
- 부모는 여러 자식을 가질 수 있다. 자식은 부모보다 들여쓰기 되어있다
    - mysql 8.0.16 이상
        
        ```sql
        EXPLAIN FORMAT=TREE SELECT * FROM employees WHERE dept_id = 100;
        ```
        
- 형제는 같은 들여쓰기 수준을 하고있다.
- 형제중에 위쪽의 오퍼레이션이 형이다
- 자식이 부모보다 먼저수행
- 형제간에는 형이 먼저수행(위쪽)

### 1.5 실제 실행계획 확인하기

- GATHER_PLAN_STATISTICS 힌트사용
    - 권한이 필요한테이블 : V*$SQL, VSQLPLANSTATISTICSALL*,*V*SQL_PLAN, V$_SESSION
- SQL_ID, CHILDNUMBER 찾는 쿼리
    
    > SELECT T1.SQL_ID, T1.CHILD_NUMBER, T1.SQL_TEXT
    > 
    > 
    > FROM V$SQL T1
    > 
    > WHERE T1.SQL_TEXT LIKE '%GATHER_PLAN_STATISTICS%'
    > 
    > ORDER BY T1.LAST_ACTIVE_TIME DESC;
    > 
- 실제 실행계획 조회하기
    
    > SELECT *
    > 
    > 
    > FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('SQL_ID',CHILD_NUMBER,'ALLSTATS LAST'));
    > 
- 실행계획 조회
<img width="815" height="546" alt="image" src="https://github.com/user-attachments/assets/bd4df1c3-55c4-4d51-988c-36b7379d24f4" />

- 항목 설명
    - ID : 실행계획의 오퍼레이션 ID
    - OPERATION : 해당 단계에서 수행한 작업
    - NAME :해당 단계에 작업을 수행한 대상 오브젝트(테이블 OR 인덱스)
    - STARTS : 해당단계 수행 횟수
    - E-ROWS : 해당 단계의 예상 데이터 건수
    - ***A-ROWS : 해당 단계의 실제 데이터 건수***
    - A-TIME : 해당 단계까지 수행된 실제 시간(누적)(A-TIME은 복잡한 실행계획이나 병렬 쿼리에서는 부정확하게 나오는 경우도 있다)
    - ***BUFFERS : 해당 단계까지 메모리 버퍼에서 읽은 블록수(논리적 IO횟수, 누적)***
    - ***READS : 해당 단계까지 디스크에서 읽은 블록 수(물리적 IO횟수, 누적)***
    - OMEM, 1MEM, USED-MEM : SQL처리를 위해 사용한 메모리 수치
- A-ROWS, A-TIME, BUFFERS가 성능 개선을 위해 주의깊게 볼 항목이다 이 항목들이 눈에띄게 수치가 높아진단계가 있다면 해당 부분의 원인을 찾아 개선하면된다.
- 운영서비스 SQL은 GATHER_PLAN_STATISTICS 힌트를 제외해야한다, 불필요한 수치 수집으로 성능상 손해 볼수있다.

**MYSQL 실행계획 분석**
| **id** | **select_type** | **table** | **partitions** | **type** | **possible_keys** | **key** | **key_len** | **ref** | **rows** | **filtered** | **Extra** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | A |  | ALL |  |  |  |  | 317 | 1 | Using where; Using temporary; Using filesort |
| 1 | SIMPLE | B |  | eq_ref | PRIMARY,idx_store_store_sn_comp_sn,STORE_IDX01 | PRIMARY | 8 | A.SN | 1 | 100 |  |
| • **의미**: 쿼리 안에서 몇 번째 SELECT 문인지 알려주는 번호예요.<br>• **예시**: 이미지에서 두 행 모두 '1'이라고 표시되어 있어요. 이것은 첫 번째 SELECT 문에 대한 실행 계획이라는 뜻이에요. | **select_type**<br>• **의미**: 어떤 종류의 SELECT 문인지 알려줘요.<br>• **예시**: 'SIMPLE'은 가장 기본적인 SELECT 문이라는 뜻이에요. 다른 SELECT 문 안에 들어있지 않은 독립적인 쿼리를 말해요. | **table**<br>• **의미**: 데이터를 가져오는 테이블의 이름이에요.<br>• **예시**: 'A'와 'B'라는 두 개의 테이블에서 데이터를 가져오고 있어요. 마치 친구 A와 친구 B에게서 각각 정보를 모으는 것과 같아요. | **partitions**<br>• **의미**: 테이블이 여러 부분으로 나뉘어져 있다면, 어떤 부분을 사용하는지 알려줘요.<br>• **예시**: 이 칼럼은 비어 있어요. 즉, 테이블이 나뉘어져 있지 않거나 모든 부분을 사용한다는 뜻이에요. | **type**<br>• **의미**: 데이터를 어떻게 찾는지 알려주는 중요한 정보예요. 학교에서 친구를 찾는 방법과 비슷해요.<br>• **예시**:<br>◦ 'ALL'은 A 테이블의 모든 행을 하나하나 다 살펴본다는 뜻이에요. 마치 전교생을 한 명씩 모두 확인하는 것처럼요.<br>◦ 'eq_ref'는 B 테이블에서는 딱 맞는 키(고유한 이름표)로 빠르게 찾는다는 뜻이에요. 마치 출석번호로 바로 친구를 찾는 것과 같아요. | **possible_keys**<br>• **의미**: 데이터를 빨리 찾기 위해 사용할 수 있는 '지름길'(인덱스)의 목록이에요.<br>• **예시**: B 테이블에서는 'PRIMARY' 인덱스라는 지름길을 사용할 수 있어요. A 테이블에서는 지름길이 없어요. | **key**<br>• **의미**: 실제로 사용된 '지름길'(인덱스)의 이름이에요.<br>• **예시**: B 테이블에서는 'PRIMARY' 인덱스를 실제로 사용했어요. | **key_len**<br>• **의미**: 인덱스에서 사용된 부분의 길이예요. 숫자가 작을수록 빠르게 찾을 수 있어요.<br>• **예시**: B 테이블의 PRIMARY 인덱스는 8바이트 길이를 사용했어요. | **ref**<br>• **의미**: 인덱스와 비교하는 데 사용된 값이나 칼럼이 무엇인지 알려줘요.<br>• **예시**: B 테이블에서는 'A'의 값을 사용해서 비교했어요. 즉, A 테이블의 어떤 칼럼과 B 테이블을 연결했다는 뜻이에요. | **rows**<br>• **의미**: 대략 몇 개의 행을 살펴봐야 할지 예상한 숫자예요.<br>• **예시**: A 테이블에서는 약 317개의 행을 살펴봐야 한다고 예상해요. B 테이블에서는 딱 1개의 행만 살펴보면 돼요. | **filtered**<br>• **의미**: 조건에 맞는 행의 비율(%)이에요.<br>• **예시**: A 테이블은 결과의 1%만 남을 거라고 예상해요. B 테이블은 100%가 결과에 남을 거라고 예상해요. | **Extra**<br>• **의미**: 추가 정보를 알려주는 부분이에요.<br>• **예시**: A 테이블에서는 'Using where; Using temporary; Using filesort'라고 나와있어요. 이것은:<br>1. 'Using where': WHERE 조건으로 결과를 추가로 걸러낸다는 뜻이에요.<br>2. 'Using temporary': 임시 테이블을 만들어서 작업한다는 뜻이에요.<br>3. 'Using filesort': 결과를 정렬한다는 뜻이에요. |



→ 전체적으로 이 쿼리는 A 테이블의 모든 데이터를 살펴본 후 조건에 맞는 것만 골라내고, 그 다음 B 테이블에서 관련된 데이터를 빠르게 찾아 합치는 작업을 하고 있어요.

## 2. 성능 개선을 위한 최소한의 지식

### 2.1 옵티마이저

- 성능 최적화를위해 실행계획을 만드는 역할
- CBO(비용 기반 옵티마이저), RBO(규칙 기반 옵티마이저)가 있으며 **현재 대부분의 RDBMS는 CBO를 사용**
- CBO의 비용은 **I/O횟수, CPU TIME, 메모리 사용량**을 의미
- 비용산출시 가장중요한것은 **테이블의 통계정보**

### 2.2 소프트 파싱, 하드 파싱

- SQL처리순서
    - 구문분석 : 문법검사, 의미검사(실제존재하는지), 권한검사
    - 소프트 파싱 : **SQL실행계획이 메모리에있는지 검색, 있으면 만들어놓은 실행계획 재사용 (빠름)**
    - 하드 파싱 : **메모리에 없으면 옵티마이저가 실행계획을 새로 만드는 작업**
 
<img width="1434" height="872" alt="image" src="https://github.com/user-attachments/assets/efe0bffb-57eb-41fb-b0b6-c56af3c0ae0e" />

- ***MySQL 8.0 이후 쿼리 캐시 기능 대신 도입된 최적화 기법***
    
    ### 1. 준비된 문장(Prepared Statements) 캐싱
    
    - **작동 방식**: SQL 문장을 미리 컴파일하고 실행 계획을 저장
    - **이점**: 동일한 구조의 쿼리를 다른 파라미터로 반복 실행할 때 효율적
    - **관련 변수**: `performance_schema.prepared_statements_instances`로 모니터링 가능
    
    ### 2. 실행 계획 캐싱(Optimizer Trace)
    
    - **작동 방식**: 옵티마이저는 파라미터가 다르더라도 유사한 쿼리의 실행 계획을 재활용
    - **관련 설정**: `optimizer_switch` 파라미터로 세부 동작 제어 가능
    
    ### 3. InnoDB 버퍼 풀(Buffer Pool)
    
    - **작동 방식**: 자주 액세스하는 데이터 페이지와 인덱스를 메모리에 캐싱
    - **설정**: `innodb_buffer_pool_size`로 크기 조정
    - **모니터링**: `SHOW ENGINE INNODB STATUS`로 상태 확인
    
    ### 4. 테이블 통계 정보 캐싱
    
    - **작동 방식**: 테이블 및 인덱스 통계를 메모리에 유지하여 실행 계획 수립 속도 향상
    - **관련 설정**: `information_schema_stats_expiry` 변수로 통계 갱신 주기 설정
    
    ### 5. 파티션 프루닝(Partition Pruning)
    
    - **작동 방식**: 쿼리와 관련 없는 파티션을 실행 계획에서 제외하여 성능 향상
    - **사용법**: 파티션 키에 기반한 조건으로 쿼리 작성
    
    ### 6. 히스토그램 통계(Histogram Statistics)
    
    - **작동 방식**: 컬럼 데이터 분포에 대한 상세 정보를 통해 정확한 실행 계획 수립
    - **생성 방법**: `ANALYZE TABLE table_name UPDATE HISTOGRAM ON column_name`
    
    ### 7. 다중 인덱스 접근 최적화(Multi-Range Read)
    
    - **작동 방식**: 비순차적 디스크 접근을 최소화하여 읽기 성능 향상
    - **관련 설정**: `optimizer_switch='mrr=on,mrr_cost_based=on'`
    
    ### 8. 쿼리 블록 중첩-루프 조인 최적화(Block Nested-Loop Join)
    
    - **작동 방식**: 조인 버퍼를 사용하여 중첩 루프 조인의 성능 향상
    - **관련 설정**: `join_buffer_size`로 조인 버퍼 크기 조정
- 실행계획 생성은 제법 큰 비용이 소모
- **바인드 변수 사용시 동일 SQL을 소프트 파싱하여 사용가능.** (텍스트가 하나라도 다를경우 다른 SQL로 인식함)
- 바인드변수 사용시에도 성능이 나빠질수있지만 OLTP시스템은 소프트파싱으로 개발해야한다. 하드파싱이 많은 CPU자원을 사용하기때문
    - 🤔 OLTP SYSTEM?
    
    > OLTP VS OLAP
    > 
    
    | **구분** | **OLTP (거래처리)** | **OLAP (분석처리)** |
    | --- | --- | --- |
    | 목적 | 일상적인 업무처리, 거래처리 | 의사결정 지원, 데이터 분석 |
    | 처리방식 | 실시간 처리 | 배치 처리 |
    | 데이터 특성 | 현재 데이터 | 이력 데이터 |
    | 트랜잭션 | 단순하고 짧은 트랜잭션 | 복잡하고 긴 트랜잭션 |
    | 사용자 | 다수의 일반 사용자 | 소수의 분석가/의사결정자 |
    | 데이터 크기 | 상대적으로 작은 데이터 | 대용량 데이터 |
    | 응답시간 | 밀리초 단위의 빠른 응답 | 분/시간 단위의 응답 허용 |
    | 최적화 방향 | 빠른 응답시간, 동시처리 | 복잡한 쿼리 처리능력 |
    
    → 따라서 OLTP 시스템에서는 소프트 파싱을 활용하여 빠른 응답시간을 확보하는 것이 중요하며, OLAP 시스템에서는 복잡한 분석을 위한 쿼리 최적화가 더 중요

  ### 2.3 IO(INPUT, OUTPUT)

- 성능개선의 핵심은 IO, 가장중요한부분이라 볼수 있음
- **불필요한 I/O를 찾아야한다**
- I/O개선을 위한방법
    - 불필요한 테이블 사용하는지
    - 불필요한 데이터를 조회하는지
    - 불필요한 부분 제거
    - 인덱스 고민(최소의 I/O처리를위해) > ***찾으려는 데이터가 너무많을경우에는 인덱스가 비효율***

### 2.4 블록

- 오라클 **I/O처리 최소단위**, MS-SQL/MY-SQL은 페이지
- **최소 크기로 데이터가 저장되도록 테이블 설계필요**
- 불필요하게 큰 데이터가 저장되면 블록하나에 저장할수있는 데이터 건수가 작아지며, 이로인해 I/O횟수가 늘어난다.
- I**/O최적화를 위해 하나의 블록에 많은 데이터가 들어가도록 설계가 필요.**

### 2.5 논리적 I/O와 물리적I/O

- **논리적 I/O는 BUFFERS(메모리), 물리적 I/O는 READ(DISK)로 표시**
- 논리적I/O : 버퍼캐시(메모리) 에서 필요한 데이터를 가져오는 것
- 물리적 I/O : 버퍼캐시에 원하는 데이터가 없으면 디스크에서 데이터블록을 가져옴
- 처음 SQL실행시 느리지만 같은 SQL을 바로실행하면 빠르게 결과가나오는데 첫번째는 디스크 두번째는 버퍼캐시에서 가져오기때문이다.
- 버퍼캐시는 제한된자원이라 LRU알고리즘. 가장오래전 사용된 데이터를 날림.
- DB성능향상을 위해 메모리 추가하는것을 고려해볼수있음(H/W적 방법)
- 실행계획에서 BUFFER항목을 항상 주의깊게 봐야함, 성능이 나빠진 증거를 찾을 수 있다

### 2.6 부분 범위 처리

- SQL을 실행시 조건에 맞는 데이터를 필요한 만큼만 찾아서 내보내는 처리방식
- SQL결과 집합의 총건수가 500건이고 화면에 보여줄 데이터가 50건일때, 화면에 먼저보여줄 50건만 우선처리하여 전송.
- 부분범위 처리는 빠른 응답시간을 보장해준다.
- 처리과정
    1. SQL조건에 맞는 데이터를 요청건수만큼 찾을때까지 읽는다
    2. 요청건수만큼 데이터 찾으면 결과를 사용자에게 보냄
    3. 첫번째 결과보낸상태에서 사용자의 다음 데이터 요청을 기다린다.
1. 다음데이터 요청하면, 1에서 멈춘지점부터 읽으면서 조건에 맞는 데이터를 요청건수만큼 채워 사용자에게 전송
- GROUP BY나 ORDER BY, 그룹함수(SUM, AVG~등)을 사용할때는 데이터 일부분만 처리하기 쉽지않다.
- ORDER BY는 정렬된 집합을 얻으려면 전체데이터를 읽어야함.하지만 SQL과 인덱스에 따라 데이터 찾는과정을 손쉽게 범위처리할수도있음.



