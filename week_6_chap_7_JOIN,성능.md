# 조인의 내부적인 처리 방식

- 조인에는 이너-조인, 아우터-조인, 카테시안-조인이 있다.
- 이너-조인: 조인 조건이 참인 경우의 데이터만 결과에 참여시킴
- 아우터-조인: 조인 조건에 만족하지 않아도 기준이 되는 쪽의 데이터는 무조건 결과에 참여시킴

### (오라클 기준) 내부적으로 조인이 처리 되는 방식

- 내부적으로는 다양한 방식으로 조인을 처리함
- 이 방식들을 이해 → 성능 개선 작업에 큰 도움이 됨
- **실제로 힌트를 사용해 조인 처리 방식만 변경해도 성능 개선이 이루어지기도 함**

1. NESTED LOOPS JOIN
2. MERGE JOIN
3. HASH JOIN

어떤 조인 처리 방식을 사용하든 조인 결과에는 영향을 주지 않는다.

---

### 1. NESTED LOOPS JOIN

- NL 조인 이라고 부름
- 중첩된-반복문 형태로 데이터를 연결하는 방식 (N중 for문..)
- 가장 오래된 방식, 가장 많이 사용하는 내부 조인 처리 방식
- 선행 집합(=선행 테이블)과 후행 집합(=후행 테이블)의 정의가 매우 중요
    - 선행: 조인을 위해 먼저 접근하는 쪽, 바깥쪽 루프
    - 후행: 뒤에 접근하는 쪽, 안쪽 루프
- 많은 양의 데이터를 조인하기에는 한계가 있다
- OLTP 시스템에서 자주 사용되는 핵심SQL은 NL조인으로 처리해야한다
    - OLTP?
        
        **OLTP (Online Transaction Processing)**
        
        ➡️ 고객 주문, 로그인, 결제 등 "짧고 빠르게 처리돼야 하는 트랜잭션 위주 시스템".
        
        ### OLTP 특징
        
        | 항목 | 설명 |
        | --- | --- |
        | 트랜잭션 수 | 많음 (수천~수만 건 동시) |
        | 쿼리 복잡도 | 낮음 (단순한 조회 or 단일 row 작업) |
        | 응답 속도 | 매우 중요 (수 ms~수백 ms) |
        | 데이터 범위 | 매우 작음 (Index 기반 Access 위주) |
        | 대표 예 | 쇼핑몰, 은행, 포털, 게임 서버 등 |
    - 의미?
        - NL조인은 하나씩 돌면서 매칭하는 방식이다. 
        즉, **작은 범위의 데이터를 자주, 빠르게 조회할 때 유리**하다.
        - 핵심 SQL ⇒ 자주 실행되는, 서비스의 핵심 기능을 담당하는 쿼리
            
            이런 쿼리는 성능 민감도가 높아서 → **정밀하고 빠른 쿼리**가 필요함
            
        - 따라서 **Index + NL 조인 조합으로 계획이 세워져야** 성능이 보장됨
        - 반대로,
            - **Hash Join**: 메모리 쓰고 한 번에 몰아서 처리 (배치에 적합)
            - **Merge Join**: 정렬이 필요함 → 느림
            
            이들은 OLAP(분석) 시스템에 더 적합함. (보고서, 대량 처리, 통계 분석 등)
            

- **✅ Oracle의 조인 힌트: `LEADING`과 `USE_NL`**
    
    Oracle에서는 옵티마이저 힌트를 통해 조인의 수행 순서와 방식에 영향을 줄 수 있다. 대표적인 힌트로는 `LEADING`과 `USE_NL`이 있다.
    
    ```sql
    SELECT /*+ LEADING(T1) USE_NL(T2) */
           ...
    FROM   table1 T1
           JOIN table2 T2 ON T1.id = T2.id;
    ```
    
    - `LEADING(T1)`
        - **조인의 시작 테이블을 T1으로 강제**함.
        - 옵티마이저가 조인 순서를 자동으로 결정하지 않게 하려는 의도
    - `USE_NL(T2)`
        - **Nested Loop 조인 방식을 사용해서 T2를 읽도록 지정**함.
        - 즉, T1의 한 row마다 T2를 검색하게 된다.(중첩 반복 조인)
    
    이 힌트를 같이 쓰면:
    
    > 옵티마이저야, T1 먼저 읽고, 그 후에 T2를 Nested Loop 방식으로 조인해줘!
    > 
    
- **✅ MySQL에서는 어떻게 할까?**
    
    MySQL은 오라클처럼 **힌트 기반 조인 제어**가 아닌, **인덱스, 통계, 조건절**에 의해 **자동으로 조인 순서와 방식을 결정**한다. 하지만 힌트처럼 사용할 수 있는 것들이 있다.
    
    **1. STRAIGHT_JOIN**
    
    조인 순서를 명시하고 싶을 때 사용:
    
    ```sql
    SELECT ...
    FROM table1 STRAIGHT_JOIN table2 ON table1.id = table2.id;
    ```
    
    - 👉 **table1을 먼저 읽고**, 그다음 table2를 읽으라는 의미.
    - Oracle의 `LEADING(table1)`과 비슷한 효과
    
    ---
    
    **2. FORCE INDEX / USE INDEX**
    
    Nested Loop을 유도하려면, **인덱스를 강제**해서 옵티마이저가 Nested Loop을 택하게 유도할 수 있다
    
    ```sql
    SELECT ...
    FROM table1 STRAIGHT_JOIN table2 
    FORCE INDEX (idx_id) 
    ON table1.id = table2.id;
    ```
    
    - `USE INDEX`, `FORCE INDEX`, `IGNORE INDEX` 등으로 옵티마이저의 접근 방법에 영향을 줄 수 있다.
    - **MySQL은 힌트로 조인 알고리즘을 직접 지정할 수 없지만**, 인덱스를 통해 간접적으로 유도할 수 있음.
    
    ---
    
    참고
    
    - MySQL은 JOIN 방식 선택에 자동 최적화를 많이 함
    - MySQL 8.0 이후부터는 옵티마이저가 더 똑똑해져서 힌트보다는 **인덱스 관리와 통계 분석이 더 중요**해졌다.
    - 복잡한 쿼리에서는 `EXPLAIN`으로 실행 계획을 꼭 확인해보기
    
    **✅ 요약 비교**
    
    | 기능 | Oracle | MySQL |
    | --- | --- | --- |
    | 조인 순서 지정 | `LEADING(T1)` | `STRAIGHT_JOIN` |
    | 조인 방식 지정 (Nested Loop) | `USE_NL(T2)` | 불가 (인덱스로 유도) |
    | 옵티마이저 개입 차단 | 힌트로 직접 제어 | 인덱스/조건절로 간접 유도 |

  - 성능 테스트 - 고려사항
    - 후행 집합의 조인 조건 컬럼에는 인덱스가 필수다
    - 후행 집합에 사용된 조인 조건과 WHERE 조건 컬럼에 복합 인덱스를 고려해야 한다.
    - **조인 횟수를 줄여야 한다.**
        - NL 조인에서 조인 횟수를 줄인다는 것은, 선행 집합의 결과 건수를 줄이는 것이다 ⇒ 성능 업
        - 중첩된-반복문에서, 바깥쪽의 반복 횟수를 줄이면 안쪽의 반복 횟수도 줄게된다.
        - **체크 방법 순서**
            - 후행 집합의 접근 횟수 줄이기 
            → 조회 조건 각각 데이터 건수 카운트 체크(WHERE 조건 포함해서) 
            → NL 조인의 선행 집합을 바꾸기

---

### 2. MERGE JOIN

- 두 데이터 집합을 연결 조건 값으로 정렬한 후 조인을 처리하는 방식
- 정렬된 데이터를 순차적으로 비교하면서 매칭하는 방식
- 연결 조건 기준으로 정렬이 되어있어야만 조인이 가능함
    - 소트 머지 조인, 소트 조인 으로도 불린다
    
    ⇒ 두 테이블이 **정렬된 상태**일 때 유리한 방식.
    
- 대량 데이터 처리에 효과적이지만, **정렬 비용**이 클 수 있다

- ✅ 오라클의 `USE_MERGE` 힌트
    
    ```sql
    SELECT /*+ USE_MERGE(T2) */
           ...
    FROM   table1 T1
    JOIN table2 T2 ON T1.id = T2.id;
    ```
    
    - **T2와의 조인을 Merge Join 방식으로 하라**는 옵티마이저 힌트이다.
    - 주로 양쪽 테이블 모두 정렬되어 있거나, 인덱스를 활용해 정렬 가능할 때 사용
    - 옵티마이저는 기본적으로 여러 조인 전략 (Nested Loop, Hash Join, Merge Join) 중 하나를 선택하는데, 이 힌트는 **Merge Join을 강제**함.
    
- **✅ MySQL에서는 어떻게 대체할 수 있을까?**
    
    MySQL은 **조인 방식 선택을 자동으로 처리**하기 때문에, **직접 Merge Join을 강제할 수는 없다.**
    하지만, Merge Join이 효과적일 수 있는 상황을 **유사하게 유도**하는 건 가능하다.
    
    - MySQL의 Merge Join 대체 방법 (간접적)
        
        1. **정렬 조건을 만족하도록 쿼리 조정**
        
        ```sql
        SELECT ...
        FROM table1
        JOIN table2 ON table1.id = table2.id
        **ORDER BY table1.id, table2.id;**
        ```
        
        - 두 테이블이 이미 정렬되어 있거나 인덱스를 활용하면, 옵티마이저가 **Block Nested Loop 또는 Sort-Merge 형태로 동작**할 수 있다.
        
        2. **인덱스 최적화**
        
        - Merge Join은 기본적으로 **정렬**이 기반이므로, **조인 조건 컬럼에 인덱스를 구성**하면 옵티마이저가 더 빠르게 처리할 수 있다.
        
        ```sql
        ALTER TABLE table1 ADD INDEX idx_id(id);
        ALTER TABLE table2 ADD INDEX idx_id(id);
        ```
        
    
    - **그럼 MySQL은 언제 Merge Join처럼 동작할까?**
        
        MySQL의 옵티마이저가 판단하여 내부적으로 비슷한 로직을 쓸 수는 있지만,
        직접 `USE_MERGE`처럼 **명시적으로 "이 조인 방식 써!"라고 강제할 수는 없다.**
        
        ➡ 대신, `EXPLAIN` 명령어로 조인 방식이 어떻게 동작하는지 확인 가능하고, 인덱스 및 정렬 조건을 통해 우회적으로 유도 가능.
        
    - 요약 비교
    
    | 기능 | Oracle | MySQL |
    | --- | --- | --- |
    | Merge Join 강제 | `USE_MERGE(T2)` | 불가 (자동 결정) |
    | 정렬 기반 조인 방식 | 명시적으로 Merge Join 사용 | 인덱스와 정렬 조건으로 간접 유도 |
    | **성능 튜닝** | **힌트 사용** | **인덱스 + `EXPLAIN` 분석 활용** |
    
    **🔍 추가 팁: MySQL에서 Merge Join을 유도하고 싶다면**
    
    1. 조인 조건 컬럼에 **양쪽 모두 인덱스** 부여
    2. 조인 전에 데이터가 **정렬된 상태**로 만들어짐을 보장
    3. `EXPLAIN`으로 `Using index`나 `range`, `index_merge` 전략이 쓰이는지 확인

---

### 3. HASH JOIN

- 해시 함수를 이용한 처리 방식
    - 조인 조건 컬럼으로 **작은 테이블을 메모리에 해시 테이블로 만들고**, 큰 테이블을 스캔하면서 매칭.
- 다른 방식보다 더 많은 CPU와 메모리 자원을 사용
- 대용량 데이터 테이블끼리 조인할 때 적합하다
- NL 조인처럼 후행 집합을 반복해서 접근하는 비효율이 없다
머지 조인처럼 정렬 작업 수행도 안한다
But 고비용의 해시 함수와 메모리의 일부인 해시 영역(HASH AREA)을 사용하는 비용이 추가된다
    - 정렬이 필요 없고, **조건만 충족하면 빠르게 검색** 가능해.
    - 단점으로 작은 테이블이 메모리에 올라가야 하므로, 메모리가 부족하면 성능 저하가 있다는 점.
- NL 조인과 머지 조인의 단점을 모두 커버하지만, 시스템 자원을 소모한다는 단점.

- **✅ 오라클의 `USE_HASH` 힌트**
    
    ```sql
    SELECT /*+ USE_HASH(T2) */
           ...
    FROM   table1 T1
    JOIN table2 T2 ON T1.id = T2.id;
    ```
    
    - **T2 테이블과의 조인을 Hash Join 방식으로 수행하라**는 힌트
    - 옵티마이저가 다른 조인 방식(Nested Loop, Merge Join)보다 **Hash Join을 우선 고려**하게 만듦
- 
    
    ```sql
    SELECT /*+ USE_HASH(T2) */
           ...
    FROM   table1 T1
    JOIN table2 T2 ON T1.id = T2.id;
    ```
    
    - **T2 테이블과의 조인을 Hash Join 방식으로 수행하라**는 힌트
    - 옵티마이저가 다른 조인 방식(Nested Loop, Merge Join)보다 **Hash Join을 우선 고려**하게 만듦
- **✅ MySQL에서는?**
    
    MySQL에서는 아직까지도 **Hash Join을 직접 명시하거나 강제하는 힌트는 없음**.
    
    하지만, MySQL 8.0 이후부터 **자동으로 Hash Join을 사용할 수 있게 되었다.**
    
    **🔹 MySQL 8.0 이상: Hash Join 지원 (자동)**
    
    ```sql
    EXPLAIN FORMAT=TRADITIONAL
    SELECT ...
    FROM table1
    JOIN table2 ON table1.id = table2.id;
    ```
    
    이런 쿼리에서 MySQL이 내부적으로 Hash Join을 **자동으로 판단해서 사용할 수 있다.**
    
    - 어떻게?
        
        MySQL 옵티마이저는 조인 방식을 선택할 때,
        여러 전략(Nested Loop, Block Nested Loop, Hash Join 등)을 **비용 기반(cost-based)**으로 비교하고, **가장 저렴한 실행 비용을 가진 방법을 선택**한다.
        
    - Hash Join이 선택되는 조건 (MySQL 8.0 기준)
        
        옵티마이저가 다음 조건을 만족하면 Hash Join을 **우선 고려**한다.
        
        | 조건 | 설명 |
        | --- | --- |
        | 1. **동등 조인** | `=` 연산이 사용된 `ON` 절만 가능 (비교 연산자 안 됨) |
        | 2. **조인되는 두 테이블 중 하나는 작음** | 한쪽 테이블을 메모리에 해시 테이블로 만들 수 있을 만큼 작아야 |
        | 3. **조인 조건 컬럼이 인덱스를 사용하지 않는 경우** | NL Join의 성능이 떨어질 수 있으므로 Hash Join 고려 |
        | 4. **인덱스 없는 조인 조건 또는 `ref` 방식 불가** | Index 기반 조인이 어려우면 Hash Join이 유리할 수 있음 |
        | 5. **join_buffer_size가 충분히 클 경우** | 작은 테이블을 메모리에 올릴 수 있어야 Hash Join 사용 가능 |
        | 6. `internal_tmp_mem_storage_engine=TempTable` | 내부적으로 해시 구조를 위해 메모리 임시 테이블 사용이 가능해야 함 |
        - 실제 판단 순서 요약
            
            ```
            1. 조인 조건 분석 → 동등 조인인가?
            2. 양쪽 테이블 크기, 인덱스 유무 확인
            3. 통계 기반으로 예상 row 수, I/O 비용 추정
            4. 각 조인 방식(NL, Hash, BNL 등)의 비용 추정
            5. 가장 낮은 비용을 가진 방식을 선택
            ```
            
            ✅ 즉, 해시 조인의 효율성이 비용 기반 평가에서 이기면 자동으로 선택됨.
            
    
    ✅ **조건**:
    
    - 조인 조건이 **동등 비교(=)**일 것
    - 옵티마이저가 Hash Join이 **가장 효율적**이라고 판단할 것
    - `EXPLAIN`에서 `join_type: hash join`으로 뜨면, Hash Join이 사용된 것.
    
    🔹 강제로 유도할 수는 없지만, 도움 되는 팁!
    
    - Hash Join 유도를 위한 환경 조건
        1. `eq_ref`나 `ref` 대신 `ALL` 스캔이 필요한 상황 만들기
        2. 작은 테이블 쪽 조건이 없도록 두기 (전체 스캔 유도)
        3. 옵티마이저 힌트 대신 **구조적인 유도** (인덱스 제거 or 통계 왜곡)
    
    ---
    
    - ✅ 요약 비교
        
        
        | 기능 | Oracle | MySQL |
        | --- | --- | --- |
        | Hash Join 강제 | `USE_HASH(T2)` | 불가 (자동 결정) |
        | 조인 전략 변경 | 힌트로 명시 가능 | 옵티마이저가 자동 판단 |
        | EXPLAIN 확인 | PLAN_TABLE에서 확인 | `join_type: hash join` (MySQL 8.0+) |
    
    ---
    

---

### 🫧 실제 저의 실무 사례에서 있었던 의문점
### 

- ⇒ 인덱스 추가로 성능 개선을 의도하고 테스트하는 과정에서, **EXPLAIN 상으로는 큰 차이가 없어 보였는데, 실제 운영 지표는 눈에 띄게 좋아짐**

> 🔎 EXPLAIN은 "예상 실행 계획",
> 
> 
> 📊 실제 DB 성능은 **"운영 환경의 다양한 변수 + 반복 실행 + 캐시 + 경쟁 상황"**이 영향을 준다.
> 

즉, `EXPLAIN`은 **단일 쿼리 기준의 이론적인 실행 비용**을 보여줄 뿐이고,

**실제 성능 변화는 그걸 수백~수천번 반복했을 때 어떤 영향이 생겼는지를 반영**한 것이다.

### 왜 EXPLAIN에서 별 효과 없어 보였을까?

### 📌 1. 인덱스 선택에 **비용 차이가 미세한 경우**

- 옵티마이저는 **비용(cost)**이 미세하게 다르면 원래 쓰던 계획을 그대로 유지하기도 한다.
- 특히 테이블이 작거나, where 조건이 selectivity가 애매하면 인덱스를 "무시"하기도 함.
- ➡️ 하지만 실사용에서는 **병렬 트래픽 + 반복 호출**로 인해 효율이 쌓이면서 차이가 커짐.

---

### 📌 2. `EXPLAIN`은 **정확한 실행 횟수와 반복 상황 반영이 안됨**

- 실무에서는 **같은 쿼리를 수천 번** 실행하게 되는데,
- 캐시, 메모리 경합, 인덱스 read path의 개선 같은 게 누적되면서 속도 차이가 나기 시작한다.

---

### 📌 3. `EXPLAIN`은 **통계 정보에 따라 추정이 틀릴 수도 있음**

- 인덱스를 막 추가하거나, `ANALYZE TABLE`을 하지 않으면 → 통계 미갱신 상태.
- 이 경우 옵티마이저가 인덱스가 유리한지도 제대로 판단 못한다.

---

### 📌 4. 쿼리 자체는 비슷한데, **조인 순서나 access type이 개선된 경우**

- 예: `ALL` → `ref` or `range` 로 바뀌었지만, cost 수치는 비슷하게 보여도
    
    → 실제 메모리/디스크 읽기 횟수는 크게 차이날 수 있다.
    

---

- **참고하면 좋은 팁**

| 팁 | 설명 |
| --- | --- |
| 📊 실제 성능 확인법 | `performance_schema`, `slow query log`, `pt-query-digest`로 확인 |
| 📌 인덱스 추가 후 `ANALYZE TABLE` 꼭 하기 | 옵티마이저가 새로운 통계 기반으로 계획 세움 |
| 🧠 쿼리 튜닝은 EXPLAIN + 실측 지표 병행! | 예상과 실제의 차이를 분석하는 게 핵심 |
| 👀 변화 체크 항목 | rows read 수, select latency, handler read count 등 |
